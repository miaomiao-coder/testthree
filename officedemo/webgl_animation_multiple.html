<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js",
					"three/addons/": "../../js/jsm/"
				}
			}




</script>
<script type="module">
    import * as THREE from 'three';

    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    //创建场景
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);
    scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);
    //添加摄像头
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(2, 1, -6);
    camera.lookAt(0, 1, 0);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // 添加平行光，平行光可以产生投影
    const dirLight = new THREE.DirectionalLight(0xffffff);
    // 设置平行光的位置
    dirLight.position.set(-3, 10, -10);
    // 设置光照产生阴影
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 4;
    dirLight.shadow.camera.bottom = -4;
    dirLight.shadow.camera.left = -4;
    dirLight.shadow.camera.right = 4;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.add(dirLight);

    //添加地面
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({
        color: 0x999999,
        depthWrite: false
    }));
    // 把平面变成水平的
    mesh.rotation.x = -Math.PI / 2;
    // 设置接收物体投影
    mesh.receiveShadow = true;
    scene.add(mesh);

    //创建渲染器
    let renderer, mixers = [];
    let clock = new THREE.Clock();

    const loader = new GLTFLoader();
    loader.load('../model/gltf/Soldier.glb', function (gltf) {

        gltf.scene.traverse(function (object) {

            if (object.isMesh) object.castShadow = true;

        });

        const model1 = SkeletonUtils.clone(gltf.scene);
        const model2 = SkeletonUtils.clone(gltf.scene);
        const model3 = SkeletonUtils.clone(gltf.scene);
        const model4 = SkeletonUtils.clone(gltf.scene);

        const mixer1 = new THREE.AnimationMixer(model1);
        const mixer2 = new THREE.AnimationMixer(model2);
        const mixer3 = new THREE.AnimationMixer(model3);
        const mixer4 = new THREE.AnimationMixer(model4);
        console.info(gltf.animations);
        mixer1.clipAction(gltf.animations[0]).play(); // idle
        mixer2.clipAction(gltf.animations[1]).play(); // run
        mixer3.clipAction(gltf.animations[3]).play(); // walk
        mixer4.clipAction(gltf.animations[2]).play(); // tpose

        model1.position.x = -3;
        model2.position.x = -1;
        model3.position.x = 1;
        model4.position.x = 3;

        scene.add(model1, model2, model3,model4);
        mixers.push(mixer1, mixer2, mixer3,mixer4);

        animate();

    });

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    createControls();

    //执行渲染操作
    function animate() {
        requestAnimationFrame(animate)
        const delta = clock.getDelta();
        for (const mixer of mixers) mixer.update(delta);
        renderer.render(scene, camera)
    }

    function createControls() {
        let controls = new OrbitControls(camera, renderer.domElement); //创建鼠标控制对象
    }
</script>
</body>
</html>