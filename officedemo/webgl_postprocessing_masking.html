<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js",
					"three/addons/": "./../js/jsm/"
				}
			}




</script>
<script type="module">
    import * as THREE from 'three';

    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {TexturePass} from 'three/addons/postprocessing/TexturePass.js'
    import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
    import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';
    import {CopyShader} from 'three/addons/shaders/CopyShader.js';
    import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
    import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';

    // https://it.cha138.com/jingpin/show-56563.html
    //添加摄像头
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 10); //设置相机位置
    //将摄像机的方向对准场景的中心点，
    // camera.lookAt(scene.position);


    //创建渲染器
    var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);//设置渲染区域尺寸
    renderer.autoClear = false;
    document.body.appendChild(renderer.domElement); //body元素中插入canvas对象

    const scene1 = new THREE.Scene();
    const scene2 = new THREE.Scene();

    let box = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ) );
    scene1.add( box );

    let torus = new THREE.Mesh( new THREE.TorusGeometry( 3, 1, 16, 32 ) );
    scene2.add( torus );


    const texture1 = new THREE.TextureLoader().load('../js/jsm/textures/758px-Canestra_di_frutta_(Caravaggio).jpg');
    texture1.minFilter = THREE.LinearFilter;
    const texture2 = new THREE.TextureLoader().load('../js/jsm/textures/2294472375_24a3b8ef46_o.jpg');

    // Texture Pass简单地将纹理以背景的形式画到渲染序列中。
    const texturePass1 = new TexturePass(texture1);
    const texturePass2 = new TexturePass(texture2);
    const clearPass = new ClearPass();

    const clearMaskPass = new ClearMaskPass();

    //创建遮罩
    const maskPass1 = new MaskPass( scene1, camera );
    const maskPass2 = new MaskPass( scene2, camera );

    const parameters = {
        stencilBuffer: true
    };
    const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);
    let composer = new EffectComposer(renderer, renderTarget);
    composer.addPass( clearPass );
    composer.addPass( maskPass1 );
    composer.addPass(texturePass1);
    // composer.addPass( clearMaskPass );
    composer.addPass( maskPass2 );
    composer.addPass(texturePass2);
    composer.addPass( clearMaskPass );
    // new ShaderPass(CopyShader) 只是输出结果，无任何特殊效果
    const outputPass = new ShaderPass(CopyShader);
    composer.addPass(outputPass);

    // Render Pass这个通道为我们需要正常显示场景的通道，也就是说这个通道里的物体是正常被绘制在屏幕上的。
    // var renderPass = new RenderPass(scene, camera);
    // composer.addPass(renderPass);

    createControls();
    render();

    //执行渲染操作
    function render() {
        requestAnimationFrame(render)
        const time = performance.now() * 0.001 + 6000;
        // box.position.x = Math.cos( time / 1.5 ) * 2;
        // box.position.y = Math.sin( time ) * 2;
        // box.rotation.x = time;
        // box.rotation.y = time / 2;
        //
        // torus.position.x = Math.cos( time ) * 2;
        // torus.position.y = Math.sin( time / 1.5 ) * 2;
        // torus.rotation.x = time;
        // torus.rotation.y = time / 2;
        renderer.clear();
        composer.render(time)
    }

    function createControls() {
        var controls = new OrbitControls(camera, renderer.domElement); //创建鼠标控制对象
    }
</script>
</body>
</html>