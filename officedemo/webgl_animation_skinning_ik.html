<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js",
					"three/addons/": "../../js/jsm/"
				}
			}








</script>
<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
    import {DRACOLoader} from 'three/addons/loaders/DRACOLoader.js';
    import {TransformControls} from 'three/addons/controls/TransformControls.js';
    import {CCDIKSolver, CCDIKHelper} from 'three/addons/animation/CCDIKSolver.js';

    //创建场景
    var scene = new THREE.Scene();
    //添加摄像头
    var camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
    camera.position.set(0.9728517749133652, 1.1044765132727201, 0.7316689528482836); //设置相机位置
    //将摄像机的方向对准场景的中心点，
    camera.lookAt(scene.position);

    //创建渲染器
    var renderer = new THREE.WebGLRenderer({antialias: true, logarithmicDepthBuffer: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);//设置渲染区域尺寸
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    document.body.appendChild(renderer.domElement); //body元素中插入canvas对象

    scene.fog = new THREE.FogExp2(0xffffff, .17);
    scene.background = new THREE.Color(0xdddddd);
    const ambientLight = new THREE.AmbientLight(0xffffff, 8); // soft white light
    scene.add(ambientLight);

    const OOI = {};
    const v0 = new THREE.Vector3();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('../js/jsm/libs/draco/');
    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);
    const gltf = await gltfLoader.loadAsync('../model/gltf/kira.glb');
    gltf.scene.traverse(n => {

        if (n.name === 'head') OOI.head = n;
        if (n.name === 'lowerarm_l') OOI.lowerarm_l = n;
        if (n.name === 'Upperarm_l') OOI.Upperarm_l = n;
        if (n.name === 'hand_l') OOI.hand_l = n;
        if (n.name === 'target_hand_l') OOI.target_hand_l = n;

        if (n.name === 'boule') OOI.sphere = n;
        if (n.name === 'Kira_Shirt_left') OOI.kira = n;

        if (n.isMesh) n.frustumCulled = false;

    });
    scene.add(gltf.scene);


    //球体添加镜面材质
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    let mirrorSphereCamera = new THREE.CubeCamera(0.05, 50, cubeRenderTarget);
    scene.add(mirrorSphereCamera);
    const mirrorSphereMaterial = new THREE.MeshBasicMaterial({envMap: cubeRenderTarget.texture});
    OOI.sphere.material = mirrorSphereMaterial;

    let controls = new OrbitControls(camera, renderer.domElement); //创建鼠标控制对象
    controls.minDistance = .2;
    controls.maxDistance = 1.5;
    controls.enableDamping = true;
    //设置控制器当前视角为球的坐标
    controls.target.copy(OOI.sphere.position);
    //controls.target.copy(OOI.sphere.position);必须在OOI.hand_l.attach( OOI.sphere )之前
    //手信息包含球体，这样手和球会一起动
    OOI.hand_l.attach(OOI.sphere);
    //添加旋转控制器
    let transformControls = new TransformControls(camera, renderer.domElement);
    transformControls.size = .75;
    transformControls.showX = false;
    transformControls.space = 'world';
    transformControls.attach(OOI.target_hand_l);
    scene.add(transformControls);

    OOI.kira.add(OOI.kira.skeleton.bones[0]);
    //数字为OOI.kira里的bones下标
    const iks = [
        {
            target: 22, // "target_hand_l"
            effector: 6, // "hand_l"
            links: [
                {
                    index: 5, // "lowerarm_l"
                    rotationMin: new THREE.Vector3(1.2, -1.8, -.4),
                    rotationMax: new THREE.Vector3(1.7, -1.1, .3)
                },
                {
                    index: 4, // "Upperarm_l"
                    rotationMin: new THREE.Vector3(0.1, -0.7, -1.8),
                    rotationMax: new THREE.Vector3(1.1, 0, -1.4)
                },
            ],
        }
    ];
    //骨骼运动
    let IKSolver = new CCDIKSolver(OOI.kira, iks);
    const ccdikhelper = new CCDIKHelper(OOI.kira, iks, 0.01);
    scene.add(ccdikhelper);

    render();

    //transformControls控制器操作时controls禁用
    transformControls.addEventListener('mouseDown', () => controls.enabled = false);
    transformControls.addEventListener('mouseUp', () => controls.enabled = true);

    //执行渲染操作
    function render() {
        if (OOI.sphere && mirrorSphereCamera) {
            OOI.sphere.visible = false;
            OOI.sphere.getWorldPosition(mirrorSphereCamera.position);
            mirrorSphereCamera.update(renderer, scene);
            OOI.sphere.visible = true;
        }

        if (OOI.head && OOI.sphere) {

            // turn head
            OOI.sphere.getWorldPosition(v0);
            OOI.head.lookAt(v0);
            OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);

        }

        if (OOI.sphere) {
            // controls follows the sphere
            //getWorldPosition把球体的世界坐标保存到v0中
            OOI.sphere.getWorldPosition(v0);
            controls.target.lerp(v0, .1);
            // controls.target.copy(v0);
        }
        IKSolver?.update();
        controls.update();
        renderer.render(scene, camera)
        requestAnimationFrame(render)
    }
</script>
</body>
</html>